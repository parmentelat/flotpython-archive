## Vidéo 1 (objets, variables, typage dynamique)

CO12AL-W2-VIDEO01.txt

## Quizz Vidéo 1

## Exercices Vidéo 1

# un notebook qui introduit la fonction built-in type
CO12AL-W2-VIDEO01-NB01.ipynb

###################################################################

## Vidéo 2 (types numériques : int, long, float, complex, bool)

CO12AL-W2-VIDEO02.txt

## Quizz Vidéo 2

## Exercices Vidéo 2

# opérations bitwise : et ou negation shifts
CO12AL-W2-VIDEO02-NB01.ipynb
limitation de la précision des floats et module decimal 


###################################################################

## Vidéo 3 (séquences)

CO12AL-W2-VIDEO03.txt

## Quizz Vidéo 3

## Exercices Vidéo 3

slicing - indices négatifs
opérations génériques sur les séquences en prenant une str comme exemple
XXX Thierry : le cours a déjà utilisé les strings, pourquoi ne pas prendre les listes justement
XXX Arnaud : je présente les listes dans la vidéo suivante, presenter en avance de phase risque d'ajouter
XXX          de la confusion pour les débutants. 
davantages de conversions : chr - ord

###################################################################

## Vidéo 4 (les listes)

CO12AL-W2-VIDEO04.txt (9 minutes)

## Quizz Vidéo 4

## Exercices Vidéo 4

sort (avec les paramètres reverse et key)
sorted()
buffer

###################################################################

## Vidéo 5 (les tuples)

CO12AL-W2-VIDEO05 ()

## Quizz Vidéo 5

## Exercices Vidéo 5
comment accéder à l'entier 3 dans L=['abc', [(1,2), ([3], 4)], 5]


###################################################################

## Vidéo 6 (101 if else)

CO12AL-W2-VIDEO06.txt (5 minutes 40 secondes)

## Quizz Vidéo 6

## Exercices Vidéo 6
-expliquer <> et dire qu'il est obsolète mais qu'on le trouve dans du
code ancien


###################################################################

## Vidéo 7 (101 boucle for et fonctions)

CO12AL-W2-VIDEO07.txt 

## Quizz Vidéo 7

## Exercices Vidéo 7



###################################################################

## Vidéo 8 (str)

CO12AL-W2-VIDEO08.txt 

## Quizz Vidéo 8

## Exercices Vidéo 8

*bytearray
*unicode
*encore du slicing et de exos du style s[:2] + 'x' + s[3:] et s[:3] + 'x' + s[3:]
*Parler du l'opérateur % pour le formatage des chaîne (on ne doit plus l'utiliser, mais on le trouve encore dans du vieux code) et notamment des notations pour les décimaux %e, %f, %g et les variantes
*parler de rjust(), ljust(), center() et format()

###################################################################

## Vidéo 9 (tables de hash)

CO12AL-W2-VIDEO09.txt 

## Quizz Vidéo 9

## Exercices Vidéo 9


###################################################################

## Vidéo 10 (dict)

CO12AL-W2-VIDEO10.txt 

## Quizz Vidéo 10

## Exercices Vidéo 10
*voir la construction D=dict(clef1=obj1, clef2=obj2)
*voir d.get('marc', '?') et son usage par rapport à d['marc']
*voir une exemple de dict dans un dict et de l'accès à ses éléments D={'alice': 35, 'enfant':{'bob' : 9, 'charlie' : 6}}

###################################################################

## Vidéo 11 (set, frozenset)

CO12AL-W2-VIDEO11.txt 

## Quizz Vidéo 11

## Exercices Vidéo 11
*autre fonctions sur les sets non vue dans la vidéo (e.g., <=, <, discard, pop, clear)
*test de performance sur le test d'appartenance entre list et set
pour expliquer qu'il faut toujours utiliser des sets
>>> timeit.timeit(setup= "x = range(2)", stmt = '"c" in x', number = 6000000)
1.042163089558322
>>> timeit.timeit(setup= "x = set(range(2))", stmt = '"c" in x', number = 6000000)
0.32964897792466274

>>> timeit.timeit(setup= "x = range(2)", stmt = '0 in x', number = 6000000)
0.3086782596151636
>>> timeit.timeit(setup= "x = set(range(2))", stmt = '0 in x', number = 6000000)
0.3819173343944584



###################################################################

## Vidéo 12 (références partagés)

CO12AL-W2-VIDEO12.txt 

## Quizz Vidéo 12

## Exercices Vidéo 12

*montrer le problème suivant L=[[1]]*5 et demander une solution pour le pas avoir de ref. partagées
*construire des exemples montrant des problèmes de ref partagées sur des mutables, e.g., 
a = [ 1, [2, 3], 4]
b = a[:]                  #shallow copy
a[0] = 'x'        #ok
a[1][1] = 'y'     #ref partagée

*voir copy.copy() pour faire les shallows copies et copy.deepcopy() pour les deep copy
* voir sys.getrefcount(1) et expliquer le résultats
* exo pour voir jusqu'à quelle taille de chaîne de caractères (et quelle taille d'entier) Python arrête de faire des références partagées pour optimiser la mémoire. 